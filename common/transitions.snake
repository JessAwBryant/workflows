"""
The idea here is that we have many short chains of rules that 
recur in many places and can build up self explanatory file names

BUT...

Often when we combine them, trying to encode the full workflow in filenames
quickly becomes impractical. 

If we use a symblic link, though, the output of one set of rules with a complicated name, can also be the simply named input of another set of rules.

Another use if for when the input file is in another part of the file system. We can link it to a simply named file to start the workflow.
"""

# dynamically generate overly specific regex constrain that lists all file names
pattern = "(" + "|".join(config.get('transitions',{}).keys()) + ")"

# transition rule will only match one of the configured files
rule transition_link:
    """ Creates a symbolic link from a config mapping """
    input: lambda w: config['transitions'][w.file_name]
    #input: lambda w: config.get('transitions',{}).get(w.file_name,'nonexistent')
    output: "{file_name}"
    wildcard_constraints:
        file_name=pattern
    params:
        abs_input = \
            lambda w: os.path.abspath(config['transitions'][w.file_name])
    shell: "rm -f {output} && ln -s {params.abs_input} {output}"

